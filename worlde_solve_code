from pickle import FALSE
import copy
from tqdm import tqdm
import time
import random

#Simple function to count number of a specific letter in a word
def num_of(a,word):
    total = 0
    for x in word:
        if x == a:
            total += 1
    return total

#Simple function to count number of a specific letter in a list
def num_of_list(a, listz):
    tot = 0
    for x in listz:
        if x == a:
            tot += 1
    return tot

#This function will calculate if a guess is possible to be the answer, given the constraints we allready know. It returns False if impossible, and True if possible
#known_place is a list of the letters we know and their place. There is a 0 instead of a letter, if we don't know what is in that position. EG: [0,"e",0,0,0]
#known is a list of the letters we do know, it includes those of known_place. It works with repeats. EG ["e","d","k"]
#not_in is  a list of letters we know are not in the answer.
#not_there is a list containing 5 lists. The first list shows what letters cannot be in the first letter of the answer. EG: [["a"],["r"],["i"],["s"],["e"]]
def is_possible(guess, known_place, known, not_in, not_there):
    for x in range(0,5):
        if guess[x] in not_in:
            return False
        if guess[x] in not_there[x]:
            return False
        if guess[x] != known_place[x] and known_place[x] != 0:
            return False
    for x in known:
        if x not in guess:
            return False
        num = num_of(x, known)
        if num == 2:
            if num_of(x,guess) < 2:
                return False
    return True

#This function will return the number of words the answer COULD be, given a set of constraints. 
def possible_option_counter(known_place, known, words, not_in, not_there):
    counter = []
    for x in words:
        if is_possible(x, known_place, known, not_in,not_there):
            counter.append(x)
    return counter

#Given a guess you make, and what the REAL answer is. This will update known_place, known, not_in, temp_not_there to reflect the extra information we gain.
def new_info(guess, answer,known_place, known, not_in, temp_not_there):
    lcv = 0
    while lcv < 5:

        #If you guessed the right letter in the right place it updates the known_place
        if guess[lcv] == answer[lcv]:
            known_place[lcv] = guess[lcv]

        #If you guessed the right letter in the wrong place it updates known. If it is not allready there
        if guess[lcv] in answer and guess[lcv] not in known:
            known.append(guess[lcv])
        
        #This fixes the repeating problem, and will make sure you get two letters in known, if you should.
        if num_of(guess[lcv], answer) == 2 and num_of(guess[lcv], guess) == 2:
            num_known = num_of_list(guess[lcv], known)
            if num_known == 0:
               known.append(guess[lcv])
               known.append(guess[lcv])
            elif num_known == 1:
                known.append(guess[lcv])
        
        #Updates not_in for letters not in the real answer
        if guess[lcv] not in answer:
            not_in.append(guess[lcv])

        #Updates not_there, if you enter a letter in a place and it is not green, you know that letter is not there
        if known_place[lcv] == 0:
            temp_not_there[lcv].append(guess[lcv])
        lcv += 1


#This function should calculate and return the best guess you can make. It will loop through all the possible guesses you can make, and then loop through all of the answers that it could be.
#With each guess, and answer you learn new information. This information is then used to calculate how many potential posssible words the answer could be, if we were had that specific answer 
#and guess. An example of this would be guess=mould, real_answer = could. We learn it ends with ould, but is not mould. The potential answers are still could, would, hould so that gets a score of 3
#We don't know the real answer, so it does this for every single possible answer. if it is could, 3, if the real answer is mould=0, real_answer= leave then we get like 400. (because we don't learn much)
#For each possible answer we get a number. Then it adds all these numbers together to get a score for that specific guess. The lowest guess wins. And is the best answer. 
def go(guess, known_place,known,not_in, not_there, five_letter_words, depth):
    depth += 1
    if depth == 6:
        print("failed", guess, known_place,known, not_there)
        return 40000
    if len(possible_option_counter(known_place, known, five_letter_words,not_in, not_there)) < 2:
        return 1
    else:
        total = 0
        for pot_ans in five_letter_words:
            if is_possible(pot_ans, known_place, known, not_in, not_there):
                temp_known_place = copy.deepcopy(known_place)
                temp_known = copy.deepcopy(known)
                temp_not_in = copy.deepcopy(not_in)
                temp_not_there = copy.deepcopy(not_there) 
                new_info(guess, pot_ans, temp_known_place, temp_known, temp_not_in, temp_not_there)
                for pot_guess in five_letter_words:
                    total += go(pot_guess, temp_known_place,temp_known,temp_not_in, temp_not_there, five_letter_words,depth)
    return total 

#This vairable stores how many potential answers you need to see before it will try to exit early. Should be over 100. 
early_fin_check = 500

#This vairable stores how far OVER the best score you have to be to exit early MUST BE OVER 1. 
early_fin_confidence = 1.3

#You can choose which wordlist to use. They are both in text files
#The num_of_words is used in the early finish
#inputs = input("Enter a to use the list of answers for wordle (2000 words), Enter e for all words you can enter (10,000): ")
inputs = "a"
if inputs == "E":
    f = open('wordlewords.txt','r')
    num_of_words = 2315
else:
    f = open('wordle_only_answers_list.txt','r')
    num_of_words = 10000
temp = f.readlines()
f.close()
five_letter_words = [word.strip() for word in temp]

#You can choose which word to start with
print("(in order) The best words to start with are:")
print("salet roate, raise, alter, arise, ")
print("")
#starts = input("Enter the word you want to start with: ")
done_words = ["salet"]
not_there = [["r"],["o"],["a"],["e"],["e"]]
known_place_list = [0,0,0,0,"t"]

print(go("ranks", known_place_list,["t"],["r","o","a","e"], not_there,five_letter_words,0))

while True:
    #Enters information we know
    known_place = input("Example (0ea00). Enter the letters that you know the place of. Use a 0 inplace of unknown letters: ")
    known = input("Enter the letters that you know in any order: ")
    not_in = input("Enter the letters that are not in in any order: ")
    print(" ")

    #Turns the infromation we know into the right format of lists
    known_place_list = []
    for x in known_place:
        if x == "0":
            known_place_list.append(0)
        else:
            known_place_list.append(x)
    
    if 0 not in known_place_list:
        break

    known_list = []
    for x in known:
        known_list.append(x)
    not_in_list = []
    for x in not_in:
        not_in_list.append(x)

    #Here, we update the not_there list. Which is slightly different than the others
    recent_word = done_words[-1]
    lcv = 0
    for x in recent_word:
        if known_place_list[lcv] == 0:
            not_there[lcv].append(recent_word[lcv])
        lcv += 1
    print("not there", not_there)
    time.sleep(2)

    for x in five_letter_words:
        print(go(x, known_place_list,known_list,not_in_list, not_there,five_letter_words,0),x)
        time.sleep(3)
    print("THE BEST WORD TO USE IS: ")
    print("")