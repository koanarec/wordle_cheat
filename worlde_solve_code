from pickle import FALSE
import copy
from tqdm import tqdm
import time
import random

#Simple function to count number of a specific letter in a word
def num_of(a,word):
    total = 0
    for x in word:
        if x == a:
            total += 1
    return total

#Simple function to count number of a specific letter in a list
def num_of_list(a, listz):
    tot = 0
    for x in listz:
        if x == a:
            tot += 1
    return tot

#This function will calculate if a guess is possible to be the answer, given the constraints we allready know. It returns False if impossible, and True if possible
#known_place is a list of the letters we know and their place. There is a 0 instead of a letter, if we don't know what is in that position. EG: [0,"e",0,0,0]
#known is a list of the letters we do know, it includes those of known_place. It works with repeats. EG ["e","d","k"]
#not_in is  a list of letters we know are not in the answer.
#not_there is a list containing 5 lists. The first list shows what letters cannot be in the first letter of the answer. EG: [["a"],["r"],["i"],["s"],["e"]]
def is_possible(guess, known_place, known, not_in, not_there):
    for x in range(0,5):
        if guess[x] in not_in:
            return False
        if guess[x] in not_there[x]:
            return False
        if guess[x] != known_place[x] and known_place[x] != 0:
            return False
    for x in known:
        if x not in guess:
            return False
        num = num_of(x, known)
        if num == 2:
            if num_of(x,guess) < 2:
                return False
    return True

#This function will return the number of words the answer COULD be, given a set of constraints. 
def possible_option_counter(known_place, known, words, not_in, not_there):
    counter = 0
    for x in words:
        if is_possible(x, known_place, known, not_in,not_there):
            counter += 1
    return counter

#Given a guess you make, and what the REAL answer is. This will update known_place, known, not_in, temp_not_there to reflect the extra information we gain.
def new_info(guess, answer,known_place, known, not_in, temp_not_there):
    lcv = 0
    while lcv < 5:

        #If you guessed the right letter in the right place it updates the known_place
        if guess[lcv] == answer[lcv]:
            known_place[lcv] = guess[lcv]

        #If you guessed the right letter in the wrong place it updates known. If it is not allready there
        if guess[lcv] in answer and guess[lcv] not in known:
            known.append(guess[lcv])
        
        #This fixes the repeating problem, and will make sure you get two letters in known, if you should.
        if num_of(guess[lcv], answer) == 2 and num_of(guess[lcv], guess) == 2:
            num_known = num_of_list(guess[lcv], known)
            if num_known == 0:
               known.append(guess[lcv])
               known.append(guess[lcv])
            elif num_known == 1:
                known.append(guess[lcv])
        
        #Updates not_in for letters not in the real answer
        if guess[lcv] not in answer:
            not_in.append(guess[lcv])

        #Updates not_there, if you enter a letter in a place and it is not green, you know that letter is not there
        if known_place[lcv] == 0:
            temp_not_there[lcv].append(guess[lcv])
        lcv += 1


def go(known_place,known,not_in, not_there, five_letter_words):
    best_word = "BADBAD"
    best_word_score = 100000000000
    words_copy = copy.deepcopy(five_letter_words)
    for guess in (words_copy):
        if is_possible(guess, known_place, known,not_in, not_there):
            temp_counter = []
            random.shuffle(five_letter_words)
            pots = tqdm(five_letter_words)
            lcv = 0
            for pot_ans in pots:
                if is_possible(pot_ans, known_place, known,not_in, not_there):
                    temp_known_place = copy.deepcopy(known_place)
                    temp_known = copy.deepcopy(known)
                    temp_not_in = copy.deepcopy(not_in)
                    temp_not_there = copy.deepcopy(not_there)
                    new_info(guess, pot_ans, temp_known_place, temp_known,temp_not_in, temp_not_there)
                    temp_counter.append(possible_option_counter(temp_known_place, temp_known, five_letter_words,temp_not_in,temp_not_there))
                    maxs = sum(temp_counter)
                    pots.set_description("{}={} BEST: {}={}".format(guess, maxs, best_word, round(best_word_score)))
                    if maxs > best_word_score or (lcv == 500 and maxs > best_word_score *0.21598272138 * 1.3):
                        maxs = 100000000
                        break
                lcv += 1
            ave = sum(temp_counter)
            if ave < best_word_score:
                best_word_score = ave
                best_word = guess
    return best_word

inputs = input("Enter A to use the list of answers for wordle (2000 words), Enter E for all words you can enter (10,000): ")
if inputs == "E":
    f = open('wordlewords.txt','r')
else:
    f = open('wordle_only_answers_list.txt','r')
temp = f.readlines()
f.close()
five_letter_words = [word.strip() for word in temp]

print("The best words to start with are:")
print("alter, arise")
print("")

starts = input("Enter the word you want to start with: ")
done_words = [starts]
not_there = [[],[],[],[],[]]
known_place_list = [0,0,0,0,0]
while True:
    
    known_place = input("Enter the letters that you know the place of. Use a 0 inplace of unknown letters. EG: 0ea00: ")
    known = input("Enter the letters that you know in any order: ")
    not_in = input("Enter the letters that are not in in any order: ")
    print(" ")

    known_place_list = []
    for x in known_place:
        if x == "0":
            known_place_list.append(0)
        else:
            known_place_list.append(x)

    known_list = []
    for x in known:
        known_list.append(x)

    not_in_list = []
    for x in not_in:
        not_in_list.append(x)

    recent_word = done_words[-1]
    lcv = 0
    for x in recent_word:
        if known_place_list[lcv] == 0:
            not_there[lcv].append(recent_word[lcv])
        lcv += 1
    print("not there", not_there)
    time.sleep(2)

    BW = go(known_place_list,known_list,not_in_list, not_there,five_letter_words)
    done_words.append(BW)
    print("THE BEST WORD TO USE IS: ",BW)